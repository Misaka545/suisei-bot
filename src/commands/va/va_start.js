// src/commands/va/va_start.js
const { ChannelType } = require("discord.js");
const {
  AudioPlayerStatus,
  EndBehaviorType,
  VoiceConnectionStatus,
} = require("@discordjs/voice");
const prism = require("prism-media");
const { Transform } = require("stream");

// States / Services (d√πng ƒë∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi)
const { ensureVA } = require("../../utils/vaState");
const { ensureChat, aiGenerate } = require("../../utils/aiChatState");
const { ensureMusic, connectIfNeeded } = require("../../utils/musicState");
const { geminiTranscribe } = require("../../services/geminiService");
const { ttsResourceFromText } = require("../../services/ttsService");
const pcmToWav48kMono = require("../../utils/pcmToWav");

// Config nh·ªè cho VA
const EPHEMERAL_FLAG = 1 << 6;
const WARMUP_FRAMES = 3;       // b·ªè v√†i khung ƒë·∫ßu ƒë·ªÉ tr√°nh h∆∞ d·ªØ li·ªáu
const HARD_TIMEOUT_MS = 7000;  // c·ª©ng timeout cho 1 l∆∞·ª£t n√≥i

module.exports = async function handleVaStart(interaction) {
  const guild = interaction.guild;
  const member = await guild.members.fetch(interaction.user.id).catch(() => null);
  const voiceChannel = member?.voice?.channel;

  if (!voiceChannel) {
    return interaction.reply({
      content: "‚ùå Join a voice channel first.",
      flags: EPHEMERAL_FLAG,
    });
  }

  // Stage channel: ph·∫£i l√† Speaker, kh√¥ng ph·∫£i Audience
  if (voiceChannel.type === ChannelType.GuildStageVoice && member.voice.suppress) {
    return interaction.reply({
      content:
        "üéôÔ∏è B·∫°n ƒëang l√† **Audience** trong Stage. H√£y **Request to Speak** r·ªìi ch·∫°y l·∫°i `/va start`.",
      flags: EPHEMERAL_FLAG,
    });
  }

  // B·∫≠t VA
  const va = ensureVA(guild.id);
  va.active = true;
  va.processing = false;

  await interaction.reply("üéôÔ∏è Voice Assistant: **ON**. (Listening)");

  // K·∫øt n·ªëi voice ‚Äî quan tr·ªçng: selfDeaf=false ƒë·ªÉ nh·∫≠n mic
  const st = await connectIfNeeded(interaction, voiceChannel, { selfDeaf: false });
  ensureMusic(guild.id); // ƒë·∫£m b·∫£o state nh·∫°c ƒë·ªÉ pause/unpause khi bot n√≥i

  const receiver = st.connection.receiver;

  // Khi c√≥ user b·∫Øt ƒë·∫ßu n√≥i ‚Üí thu v√† x·ª≠ l√Ω
  receiver.speaking.on("start", async (userId) => {
    try {
      if (!va.active || va.processing) return;
      const m = guild.members.cache.get(userId);
      if (!m || m.user.bot) return;

      // N·∫øu mu·ªën ch·ªâ nghe ng∆∞·ªùi g·ªçi l·ªánh, m·ªü d√≤ng sau:
      // if (m.id !== interaction.user.id) return;

      va.processing = true;
      console.log(`[VA] speaking start from ${m.user.tag} (${userId})`);

      // 1) L·∫•y stream Opus t·ª´ Discord ‚Üí decode v·ªÅ PCM s16le 48k mono
      const opus = receiver.subscribe(userId, {
        end: { behavior: EndBehaviorType.AfterSilence, duration: 1200 },
        autoDestroy: true,
      });

      opus.on("error", (e) =>
        console.warn("[VA] opus stream error (recoverable):", e?.message || e)
      );

      const decoder = new prism.opus.Decoder({
        frameSize: 960, // 20ms @ 48k
        channels: 1,
        rate: 48000,
      });

      decoder.on("error", (e) => {
        // frame l·ªói ‚Üí b·ªè qua
        console.warn(
          "[VA] opus decoder error (corrupted frame skipped):",
          e?.message || e
        );
      });

      const pcm = opus.pipe(decoder);

      // B·ªè v√†i frame ƒë·∫ßu (warm-up)
      let warmupLeft = WARMUP_FRAMES;
      const warmupStripper = new Transform({
        transform(chunk, _enc, cb) {
          if (warmupLeft > 0) {
            warmupLeft--;
            return cb();
          }
          cb(null, chunk);
        },
      });

      // Thu PCM sau warm-up ƒë·ªÉ ƒë√≥ng g√≥i WAV (kh√¥ng d√πng ffmpeg)
      const pcmAfterWarmStream = pcm.pipe(warmupStripper);

      let framesSeen = 0;
      let pcmBytes = 0;
      let pcmAfterWarmBytes = 0;
      const pcmChunks = [];

      pcm.on("data", (c) => {
        framesSeen++;
        pcmBytes += c.length;
      });
      pcmAfterWarmStream.on("data", (c) => {
        pcmAfterWarmBytes += c.length;
        pcmChunks.push(c);
      });

      // HARD TIMEOUT ph√≤ng k·∫πt
      const hardTimeout = setTimeout(() => {
        try { opus.destroy(); } catch {}
        try { pcm.destroy(); } catch {}
        try { pcmAfterWarmStream.destroy(); } catch {}
      }, HARD_TIMEOUT_MS);

      // ƒê·ª£i k·∫øt th√∫c n√≥i (sau 1.2s im l·∫∑ng)
      await new Promise((resolve) => {
        const done = () => resolve();
        pcmAfterWarmStream.on("end", done);
        pcmAfterWarmStream.on("close", done);
        pcmAfterWarmStream.on("error", done);
        opus.on("end", done);
        opus.on("close", done);
        opus.on("error", done);
      }).finally(() => clearTimeout(hardTimeout));

      // G√≥i WAV tr·ª±c ti·∫øp t·ª´ PCM s16le 48k mono
      const pcmBuffer = Buffer.concat(pcmChunks);
      const wav = pcmBuffer.length ? pcmToWav48kMono(pcmBuffer) : Buffer.alloc(0);
      const wavBytes = wav.length;

      console.log(
        `[VA] frames=${framesSeen} | PCM bytes=${pcmBytes} | PCM(after warmup)=${pcmAfterWarmBytes} | WAV bytes=${wavBytes}`
      );

      if (!pcmAfterWarmBytes || wavBytes < 2000) {
        va.processing = false;
        await interaction
          .followUp({
            content:
              "‚ö†Ô∏è VA kh√¥ng nh·∫≠n ƒë∆∞·ª£c √¢m thanh. (PCM OK nh∆∞ng WAV r·ªóng ‚Äì ƒë√£ b·ªè ffmpeg) H√£y th·ª≠ n√≥i g·∫ßn mic h∆°n ho·∫∑c ki·ªÉm tra thi·∫øt b·ªã ghi √¢m.",
            flags: EPHEMERAL_FLAG,
          })
          .catch(() => {});
        return;
      }

      // 2) STT (Gemini)
      let transcript = "";
      try {
        transcript = await geminiTranscribe(wav);
        console.log(
          `[VA] transcript="${(transcript || "").slice(0, 120)}${
            (transcript || "").length > 120 ? "..." : ""
          }"`
        );
      } catch (e) {
        console.error("[VA] STT error:", e);
        va.processing = false;
        await interaction
          .followUp({
            content: "‚ùå L·ªói nh·∫≠n di·ªán gi·ªçng n√≥i (STT).",
            flags: EPHEMERAL_FLAG,
          })
          .catch(() => {});
        return;
      }

      if (!transcript) {
        va.processing = false;
        return;
      }

      // 3) Wakeword (n·∫øu c√≥)
      if (
        va.wakeword &&
        !transcript.toLowerCase().includes(va.wakeword.toLowerCase())
      ) {
        console.log("[VA] wakeword not found, ignore");
        va.processing = false;
        return;
      }
      if (va.wakeword) {
        const re = new RegExp(va.wakeword, "i");
        transcript = transcript.replace(re, "").trim();
      }

      // 4) LLM (Gemini) ‚Äî h·ªôi tho·∫°i theo k√™nh
      const session = ensureChat(interaction.channelId);
      let replyText = "";
      try {
        replyText = await aiGenerate(session, transcript);
        console.log(
          `[VA] reply="${replyText.slice(0, 120)}${
            replyText.length > 120 ? "..." : ""
          }"`
        );
      } catch (e) {
        console.error("[VA] LLM error:", e);
        va.processing = false;
        await interaction
          .followUp({
            content: "‚ùå L·ªói AI t·∫°o c√¢u tr·∫£ l·ªùi.",
            flags: EPHEMERAL_FLAG,
          })
          .catch(() => {});
        return;
      }

      // 5) TTS & ph√°t ‚Äî t·∫°m d·ª´ng nh·∫°c n·∫øu ƒëang ph√°t
      const stNow = ensureMusic(guild.id);
      const pausedForVA =
        stNow?.player &&
        stNow.player.state.status === AudioPlayerStatus.Playing
          ? stNow.player.pause(true)
          : false;

      // Kh√¥ng ph√°t n·∫øu connection kh√¥ng Ready
      const isConnReady =
        st.connection &&
        st.connection.state &&
        st.connection.state.status === VoiceConnectionStatus.Ready;

      if (!isConnReady || !st.player) {
        console.warn("[VA TTS] Connection not Ready or player missing; skip play.");
        await interaction
          .followUp({
            content: `üó®Ô∏è ${replyText}`,
            flags: EPHEMERAL_FLAG,
          })
          .catch(() => {});
        if (pausedForVA) stNow?.player?.unpause();
        va.processing = false;
        return;
      }

      // G·∫Øn handler l·ªói t·∫°m th·ªùi cho player (tr√°nh crash EPIPE)
      const onPlayerError = (err) => {
        console.warn("[VA TTS] AudioPlayer error:", err?.message || err);
      };
      st.player.on("error", onPlayerError);

      try {
        const ttsRes = await ttsResourceFromText(replyText, va.lang || "auto");
        st.player.play(ttsRes);
      } catch (e) {
        console.error("[VA] TTS error:", e);
        await interaction
          .followUp({ content: `üó®Ô∏è ${replyText}`, flags: EPHEMERAL_FLAG })
          .catch(() => {});
        if (pausedForVA) stNow?.player?.unpause();
        st.player.off("error", onPlayerError);
        va.processing = false;
        return;
      }

      const onIdle = () => {
        st.player.off(AudioPlayerStatus.Idle, onIdle);
        st.player.off("error", onPlayerError);
        if (pausedForVA) stNow?.player?.unpause();
        va.processing = false;
        console.log("[VA] TTS finished");
      };
      st.player.on(AudioPlayerStatus.Idle, onIdle);
    } catch (e) {
      console.error("[VA] pipeline error:", e);
      va.processing = false;
      await interaction
        .followUp({ content: "‚ö†Ô∏è VA pipeline error.", flags: EPHEMERAL_FLAG })
        .catch(() => {});
    }
  });
};
